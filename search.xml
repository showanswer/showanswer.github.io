<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用hexo框架搭建个人博客</title>
    <url>/2020/09/13/%E4%BD%BF%E7%94%A8hexo%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="一、基础环境的搭建"><a href="#一、基础环境的搭建" class="headerlink" title="一、基础环境的搭建"></a>一、基础环境的搭建</h2><h3 id="1-1-安装node-js"><a href="#1-1-安装node-js" class="headerlink" title="1.1 安装node.js"></a>1.1 安装node.js</h3><ol>
<li><p>通过官网下载相对应的版本： <a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
</li>
<li><p>以管理员的身份打开cmd</p>
</li>
<li><p>node -v 查看版本</p>
</li>
<li><p>npm -v查看版本</p>
</li>
<li><p>由于国外网站下载速度较慢，所以我们一般会使用国内镜像这里推荐使用淘宝的源<br>使用npm下载cnpm    npm install -g cnpm -registry=<a href="https://registrynpm.taobao.org/">https://registrynpm.taobao.org</a></p>
<a id="more"></a>


</li>
</ol>
<h3 id="1-2-安装git"><a href="#1-2-安装git" class="headerlink" title="1.2 安装git"></a>1.2 安装git</h3><ol>
<li><p>百度git官网，[git] <a href="https://git-scm.com/download">https://git-scm.com/download</a> 根据自己的电脑下载相对应的版本</p>
</li>
<li><p>下载好后，傻瓜式安装即可。安装好后。在cmd中输入git 查看下载版本<br>出现版本号后就说明安装成功了。</p>
<blockquote>
<p>启动Git </p>
</blockquote>
</li>
</ol>
<p>安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！<br><strong>Git Bash:</strong>  Unix与Linux风格的命令行，使用最多，推荐最多<br><strong>Git CMD:</strong>  Windows风格的命令行<br><strong>Git  GUI:</strong>  图形界面的Git，不建议初学者使用，尽量先熟悉常用命令<br>3. 环境配置<br>     一般git 的账户和邮箱应该与GitHub上的账户保持一致。这里如果没有GitGub账户的话应该先去注册一个账户。注册好后，就可以进行配置了。<br>    <code>git config --system --list   #查看系统的config</code><br>    <code>git config --global  --list  #查看当前用户（global）配置</code><br> <strong>Git相关的配置文件：</strong><br>1）、Git\etc\gitconfig  ：Git 安装目录下的 gitconfig     –system 系统级<br>2）、C:\Users\Administrator\ .gitconfig    只适用于当前登录用户的配置  –global 全局</p>
<p>​     这里可以直接编辑配置文件，通过命令设置后会响应到这里。</p>
<ol start="4">
<li><p>设置用户名与邮箱（用户标识，必要）</p>
<pre><code>#配置用户名
   git config --global user.name &quot;username&quot;    //（ &quot;username&quot;是自己的账户名，）

   git config --global user.email &quot;username@email.com&quot;     //(&quot;username@email.com&quot;注册账号时用的邮箱)</code></pre>
<p>以上命令执行结束后，可用 git config –global –list 命令查看配置是否OK</p>
<h2 id="二、-使用cnpm-安装hexo-cli框架"><a href="#二、-使用cnpm-安装hexo-cli框架" class="headerlink" title="二、 使用cnpm 安装hexo-cli框架"></a>二、 使用cnpm 安装hexo-cli框架</h2></li>
<li><p>在任意目录下，鼠标右击，点击 Git Bash 输入cnpm install -g hexo-cli</p>
</li>
<li><p>在当前目录下创建一个blog文件夹，并进入这个文件</p>
</li>
<li><p>使用hexo init语句生成博客框架。blog文件里就会多出一些基本文件</p>
</li>
<li><p>启动博客 hexo server，本地端口4000启动。在浏览器上输入localhost:4000即可进入</p>
</li>
</ol>
<h2 id="三、-博客编辑"><a href="#三、-博客编辑" class="headerlink" title="三、 博客编辑"></a>三、 博客编辑</h2><ol>
<li>新建博客  输入语句：hexo new“博客标题名”</li>
<li>进入新建博客文件夹，编辑博客  编辑文本格式为 .md格式</li>
<li>退回blog目录，hexo clean 清理缓存， hexo g 生成代码</li>
</ol>
<h2 id="四、-博客部署"><a href="#四、-博客部署" class="headerlink" title="四、 博客部署"></a>四、 博客部署</h2><ol>
<li><p>登陆github账户，新建一个仓库。 new repository</p>
</li>
<li><p>在blog目录下装一个git部署的插件，输入语句：cnpm install hexo-deployer-git –save</p>
</li>
<li><p>设置 _config.yml文件：</p>
</li>
</ol>
<p>deploy:<br>     type: git<br>     repo: <a href="https://github.com/showanswer/showanswer.github.io.git">https://github.com/showanswer/showanswer.github.io.git</a><br>     branch: master<br>4. 部署到远端，输入语句：hexo d<br>5. 部署后，在网页搜索对应url 即可查看博客</p>
<h2 id="五、更换博客主题"><a href="#五、更换博客主题" class="headerlink" title="五、更换博客主题"></a>五、更换博客主题</h2><ol>
<li>克隆想要的hexo主题</li>
<li>cmd输入语句：<strong>git clone 主题地址 themes/主题名，将主题克隆到themes目录下</strong></li>
<li>配置主题，修改_config.yml文件，将里面的theme值改为克隆的主题名 </li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/09/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>typora练习</title>
    <url>/2020/09/13/typora%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><a id="more"></a>

<ul>
<li><p>列表1</p>
</li>
<li><p>列表2<br>a 字列表<br>b字列表</p>
</li>
<li><p>列表3</p>
</li>
</ul>
<p><a href="https://showanswer.github.io/">搭建hexo教程</a><br><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1328874460,2431333110&fm=26&gp=0.jpg" alt="头像"></p>
<p><em>字体是斜线的</em><br><strong>字体是加粗的</strong></p>
<p><code>&lt;html&gt;&lt;/html&gt;</code>  </p>
<pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;标题&lt;/title&gt;
  &lt;/head&gt;
&lt;/html&gt;


</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式探索</title>
    <url>/2020/09/19/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<p>单例模式：某个类只能存在一个对象实例， 并且该类只提供一个取得其对象实例的方法(静态方法)。</p>
<h3 id="1-饿汉式单例"><a href="#1-饿汉式单例" class="headerlink" title="1.  饿汉式单例"></a>1.  饿汉式单例</h3><ol>
<li><p>饿汉式单例：一上来初始化的时候就会加载内存中的所有东西，可能会造成内存的浪费</p>
</li>
<li><p>优点：写法简单，在类装载时就完成了实例化，避免了线程同步，没有多线程问题。</p>
</li>
<li><p>分为：静态变量，声明的时候完成实例化，静态代码块（在static{中完成对象实例化}）</p>
<p><img src="C:\Users\如果answer\Pictures\images\QQ图片20200919082402.png" alt="QQ图片20200919082402"></p>
 <a id="more"></a>

</li>
</ol>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><ol>
<li><p>懒汉式单例：什么时候使用什么时候创建对象。但是只是在单线程下单例。多线程下就可能会出现异常，就不是单例了。需要加所来解决多线程并发问题。</p>
<p><img src="C:\Users\如果answer\Pictures\images\QQ图片20200919082402.png" alt="QQ图片20200919082402"></p>
</li>
</ol>
<ol start="2">
<li><p>多线程下就会出现错误。</p>
<p><img src="C:\Users\如果answer\Pictures\images\QQ截图20200919083505.png" alt="QQ截图20200919083505"></p>
<p><img src="C:\Users\如果answer\Pictures\images\QQ截图20200919083452.png" alt="QQ截图20200919083452"></p>
</li>
</ol>
<h3 id="2-懒汉式-–》-双重检测锁模式-确保线程安全"><a href="#2-懒汉式-–》-双重检测锁模式-确保线程安全" class="headerlink" title="2.懒汉式 –》 双重检测锁模式  确保线程安全"></a>2.懒汉式 –》 双重检测锁模式  确保线程安全</h3><ol>
<li><p>因为在多线程高并发下，懒汉式单例会出现异常，所以我们需要对当前对象进行加所，保证这个类唯一。<img src="C:\Users\如果answer\Pictures\images\QQ截图20200919084721.png" alt="QQ截图20200919084721"></p>
</li>
<li><p>为什么进行两次判断当前对象是否为空？</p>
<ol>
<li><p>第一次判断是为了提高运行效率。比如，线程1，2，3都要调用getInstace函数。当线程1走完了内层判断，对象实例化了，线程3也调用了getInstace函数，如果没有加外层的判断线程3还是要继续等待线程2的完成，而加上外层判断，就不需要等待了，直接返回了实例化的对象。</p>
</li>
<li><p>第二次判断是为了只有一个实例化对象。因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p>
</li>
</ol>
</li>
<li><p>双重检测锁解决了懒汉式单例在多线程下的异常。但依然存在着问题，有者安全隐患。因为这不是一个原子性操作。不是原子性操作，在初始化对象时，会经过一下三步。</p>
<pre><code> 1. 分配内存空间
 2. 执行构造方法，初始化这个对象
 3. 将对象指向这个内存空间</code></pre>
</li>
<li><p>这里存在着指令重排的可能。正常情况下是按照123的顺序进行，但指令重排可能会132，这样就会操作，一个空对象指向内存空间的问题，线程在执行getInstace函数是，会直接返回null一个空对象。</p>
</li>
<li><p>解决方法，避免对象进行指令重排。在声明对象时加上volatile</p>
<p> <img src="C:\Users\如果answer\Pictures\images\QQ截图20200919090604.png" alt="QQ截图20200919090604"></p>
</li>
</ol>
<h3 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3. 静态内部类"></a>3. 静态内部类</h3><p>​     特点：当外部类装在时，内部类不会被装载  。当在调用getInstance函数时，会自动调用静态内部，且对静态内部类进行装载，只会装载一次。    通过类装载的方式保证了初始化实例时只有一个线程，避免了线程的安全性。效率高。推荐使用。</p>
<p><img src="C:\Users\如果answer\Pictures\images\静态内部类.png" alt="静态内部类"></p>
<ol>
<li><p>这个静态内部类 也存在着隐患。即上面的饿汉式，懒汉式也存着相同的安全隐患。—- 反射</p>
</li>
<li><p>通过反射可以破解单例模式，因为反射回无视私有的构造器。  下面拿懒汉式举例</p>
<p><img src="C:\Users\如果answer\Pictures\images\反射.png" alt="反射"></p>
<p>结果：</p>
<p><img src="C:\Users\如果answer\Pictures\images\结果.png" alt="结果"></p>
</li>
</ol>
<p>​      这就破解了单例模式。通过破坏私有化构造设置，在通过构造器创建对象。</p>
<ol start="3">
<li><p>这里可以在构造器使用三重检测锁。但是若不使用这个对象创建实例，直接使用反射。也会被破解。这里可以再加一个私有静态的布尔成员变量 在构造器中进行判断值，如果使用过构造器就改变布尔值。第二次构造的时候返回错误。但这里依然可以被反射所破解，将私有属性权限也进行破化。</p>
</li>
<li><p>可以通过使用枚举来避免反射破解单例</p>
<h3 id="4-枚举"><a href="#4-枚举" class="headerlink" title="4. 枚举"></a>4. 枚举</h3></li>
<li><p>枚举本身 也是一个类 </p>
</li>
<li><p>为什么反射无法破坏枚举？ 因为通过<strong>反编译</strong>我们可以看到 枚举这个类本使没有无参构造，只有有参构造。</p>
<p><img src="C:\Users\如果answer\Pictures\images\反编译.png" alt="反编译"></p>
<p>这里只有一个有参构造器。所以无法通过反射进行破坏。</p>
</li>
</ol>
<h3 id="使用场景和注意事项"><a href="#使用场景和注意事项" class="headerlink" title="使用场景和注意事项"></a>使用场景和注意事项</h3><p>1.在JDK 源码中  RunTime 有使用到单例模式</p>
<p><img src="C:\Users\如果answer\Pictures\images\runtime.png" alt="runtime"><br>2. 单例模式保证了系统中该类只存一个实例对象，节省了系统资源，对于一些需要频繁创建和销毁 的对象，使用单例模式可以提高系统的性能。<br>3. 创建对象时耗时过多或耗费资源过多，但又经常用到的对象，工具类的对象，频繁访问数据库或文件的对象。<br>3. 当像实例化一个对象时，必须使用相对应的方法，而不是使用new</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>-设计模式 -java</tag>
      </tags>
  </entry>
</search>
